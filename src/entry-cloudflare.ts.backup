/**
 * Cloudflare Workers Entry Point for TanStack Start Terminal
 */

interface Env {
  DB: D1Database
  SESSIONS: KVNamespace
  CACHE: KVNamespace
  STORAGE: R2Bucket
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url)

    // Handle API routes
    if (url.pathname === '/api/terminal' && request.method === 'POST') {
      try {
        const body = await request.json() as { command: string, args: string, path: string }
        const { command, args, path } = body

        // Handle various terminal commands
        switch (command) {
          case 'papers': {
            const papers = await env.DB.prepare(`
              SELECT id, title, category, reading_time, difficulty_level
              FROM papers
              WHERE published = 1
              ORDER BY created_at DESC
              LIMIT 10
            `).all()

            if (!papers.results.length) {
              return Response.json({
                output: 'No papers found.',
                type: 'info'
              })
            }

            const output = [
              '',
              '╔════════════════════════════════════════════════════════════════════╗',
              '║                     TECHNICAL PAPERS LIBRARY                       ║',
              '╚════════════════════════════════════════════════════════════════════╝',
              '',
              ...papers.results.map((p: any, i: number) =>
                `[${i + 1}] ${p.title} (${p.category}) • ${p.reading_time || '?'}min • ${p.difficulty_level || 'N/A'}`
              ),
              '',
              '────────────────────────────────────────────────────────────────────',
              'Type "read <number>" to read a paper',
              ''
            ].join('\n')

            return Response.json({
              output,
              type: 'success'
            })
          }

          case 'read': {
            if (!args) {
              return Response.json({
                output: 'Usage: read <paper-number>',
                type: 'error'
              })
            }

            const paperNum = parseInt(args)
            if (isNaN(paperNum) || paperNum < 1) {
              return Response.json({
                output: 'Please provide a valid paper number',
                type: 'error'
              })
            }

            const papers = await env.DB.prepare(`
              SELECT * FROM papers
              WHERE published = 1
              ORDER BY created_at DESC
              LIMIT 1 OFFSET ?
            `).bind(paperNum - 1).first()

            if (!papers) {
              return Response.json({
                output: `Paper #${paperNum} not found`,
                type: 'error'
              })
            }

            const output = [
              '',
              '╔════════════════════════════════════════════════════════════════════╗',
              `║ ${papers.title.padEnd(66, ' ').substring(0, 66)} ║`,
              '╚════════════════════════════════════════════════════════════════════╝',
              '',
              `Category: ${papers.category}`,
              `Reading Time: ${papers.reading_time || '?'} minutes`,
              `Difficulty: ${papers.difficulty_level || 'N/A'}`,
              '',
              '────────────────────────────────────────────────────────────────────',
              '',
              papers.excerpt_long || papers.excerpt_short || 'No description available.',
              '',
              'Type "papers" to return to the list',
              ''
            ].join('\n')

            return Response.json({
              output,
              type: 'success'
            })
          }

          case 'search': {
            if (!args) {
              return Response.json({
                output: 'Usage: search <query>',
                type: 'error'
              })
            }

            const results = await env.DB.prepare(`
              SELECT id, title, category, excerpt_short
              FROM papers
              WHERE published = 1
              AND (title LIKE ? OR content LIKE ? OR category LIKE ?)
              LIMIT 5
            `).bind(`%${args}%`, `%${args}%`, `%${args}%`).all()

            if (!results.results.length) {
              return Response.json({
                output: `No papers found matching: "${args}"`,
                type: 'info'
              })
            }

            const output = [
              '',
              `Search results for "${args}":`,
              '',
              ...results.results.map((p: any, i: number) =>
                `[${i + 1}] ${p.title} (${p.category})\n    ${p.excerpt_short || 'No description'}`
              ),
              ''
            ].join('\n')

            return Response.json({
              output,
              type: 'success'
            })
          }

          case 'ls': {
            if (path === '/' || !path) {
              return Response.json({
                output: `/
├── papers/
│   ├── automation/
│   ├── webflow/
│   ├── development/
│   └── [5 papers]
├── about/
├── contact/
└── help/`,
                type: 'success'
              })
            }

            if (path.includes('papers')) {
              const papers = await env.DB.prepare(
                'SELECT COUNT(*) as count FROM papers WHERE published = 1'
              ).first()

              return Response.json({
                output: `papers/
└── [${papers?.count || 0} technical papers]`,
                type: 'success'
              })
            }

            return Response.json({
              output: `Directory not found: ${path}`,
              type: 'error'
            })
          }

          case 'cd': {
            if (!args || args === '~' || args === '/') {
              return Response.json({
                output: '',
                type: 'success',
                newPath: '/'
              })
            }

            if (args === '..') {
              const parentPath = path.split('/').slice(0, -1).join('/') || '/'
              return Response.json({
                output: '',
                type: 'success',
                newPath: parentPath
              })
            }

            const newPath = args.startsWith('/')
              ? args
              : path === '/'
              ? `/${args}`
              : `${path}/${args}`

            return Response.json({
              output: '',
              type: 'success',
              newPath
            })
          }

          default:
            return Response.json({
              output: `Command not found: ${command}`,
              type: 'error'
            })
        }
      } catch (error) {
        console.error('Terminal command error:', error)
        return Response.json({
          output: 'Error processing command',
          type: 'error'
        }, { status: 500 })
      }
    }

    // For now, serve static HTML
    // In production, this would serve the built React app
    return new Response(`
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Create Something Terminal</title>
          <style>
            @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');

            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }

            body {
              background: radial-gradient(ellipse at center, #1A1E37 0%, #0A0E27 100%);
              color: #00FF00;
              font-family: 'JetBrains Mono', monospace;
              min-height: 100vh;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              position: relative;
              overflow: hidden;
            }

            body::before {
              content: " ";
              display: block;
              position: fixed;
              top: 0;
              left: 0;
              bottom: 0;
              right: 0;
              background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                          linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
              background-size: 100% 2px, 3px 100%;
              pointer-events: none;
              z-index: 1;
            }

            .container {
              text-align: center;
              z-index: 2;
              padding: 2rem;
            }

            h1 {
              color: #00FFFF;
              text-shadow: 0 0 10px #00FFFF, 0 0 20px #00FFFF;
              margin-bottom: 2rem;
              font-size: 2.5rem;
            }

            .ascii-logo {
              color: #00FF00;
              font-size: 0.7rem;
              line-height: 1.2;
              margin-bottom: 2rem;
              text-shadow: 0 0 5px #00FF00;
            }

            .info {
              color: #00FF00;
              margin: 1rem 0;
            }

            .status {
              color: #FFB000;
              animation: pulse 2s infinite;
            }

            @keyframes pulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.5; }
            }

            .command {
              background: rgba(0, 0, 0, 0.5);
              border: 1px solid #00FF00;
              padding: 1rem 2rem;
              margin-top: 2rem;
              border-radius: 4px;
            }

            .prompt {
              color: #00FFFF;
            }

            a {
              color: #00FFFF;
              text-decoration: none;
            }

            a:hover {
              text-shadow: 0 0 10px #00FFFF;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <pre class="ascii-logo">
   ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗
  ██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝
  ██║     ██████╔╝█████╗  ███████║   ██║   █████╗
  ██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝
  ╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗
   ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝</pre>

            <h1>CREATE SOMETHING TERMINAL</h1>

            <p class="info">TanStack Start + Cloudflare Workers</p>
            <p class="status">✓ SYSTEM ONLINE</p>

            <div class="command">
              <p class="info">Terminal API Endpoints Active</p>
              <p class="prompt">$ curl -X POST ${url.origin}/api/terminal</p>
            </div>

            <p class="info" style="margin-top: 2rem;">
              Edge Network Status: <span style="color: #00FF00;">CONNECTED</span><br>
              Database: <span style="color: #00FF00;">${env.DB ? 'ONLINE' : 'OFFLINE'}</span><br>
              Cache: <span style="color: #00FF00;">${env.CACHE ? 'ACTIVE' : 'INACTIVE'}</span>
            </p>

            <p class="info" style="margin-top: 2rem;">
              <a href="https://github.com/createsomethingtoday">GitHub</a> •
              <a href="https://createsomething.agency">Website</a>
            </p>
          </div>
        </body>
      </html>
    `, {
      headers: {
        'Content-Type': 'text/html;charset=UTF-8',
      },
    })
  },
}