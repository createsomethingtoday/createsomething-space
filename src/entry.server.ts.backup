/**
 * Server Entry Point for TanStack Start + Cloudflare Workers
 */

interface Env {
  DB: D1Database
  SESSIONS: KVNamespace
  CACHE: KVNamespace
  STORAGE: R2Bucket
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // For now, return a simple response to test deployment
    // We'll integrate TanStack Start properly later

    const url = new URL(request.url)

    if (url.pathname === '/api/terminal' && request.method === 'POST') {
      try {
        const body = await request.json() as { command: string, args: string, path: string }
        const { command, args, path } = body

        // Handle various terminal commands
        switch (command) {
          case 'papers': {
            const papers = await env.DB.prepare(`
              SELECT id, title, category, reading_time, difficulty_level
              FROM papers
              WHERE published = 1
              ORDER BY created_at DESC
              LIMIT 10
            `).all()

            if (!papers.results.length) {
              return Response.json({
                output: 'No papers found.',
                type: 'info'
              })
            }

            const output = [
              '',
              '╔════════════════════════════════════════════════════════════════════╗',
              '║                     TECHNICAL PAPERS LIBRARY                       ║',
              '╚════════════════════════════════════════════════════════════════════╝',
              '',
              ...papers.results.map((p: any, i: number) =>
                `[${i + 1}] ${p.title} (${p.category}) • ${p.reading_time || '?'}min • ${p.difficulty_level || 'N/A'}`
              ),
              '',
              '────────────────────────────────────────────────────────────────────',
              'Type "read <number>" to read a paper',
              ''
            ].join('\n')

            return Response.json({
              output,
              type: 'success'
            })
          }

          case 'read': {
            if (!args) {
              return Response.json({
                output: 'Usage: read <paper-number>',
                type: 'error'
              })
            }

            const paperNum = parseInt(args)
            if (isNaN(paperNum) || paperNum < 1) {
              return Response.json({
                output: 'Please provide a valid paper number',
                type: 'error'
              })
            }

            // Get paper by index (paper 1 = index 0)
            const papers = await env.DB.prepare(`
              SELECT * FROM papers
              WHERE published = 1
              ORDER BY created_at DESC
              LIMIT 1 OFFSET ?
            `).bind(paperNum - 1).first()

            if (!papers) {
              return Response.json({
                output: `Paper #${paperNum} not found`,
                type: 'error'
              })
            }

            const output = [
              '',
              '╔════════════════════════════════════════════════════════════════════╗',
              `║ ${papers.title.padEnd(66, ' ').substring(0, 66)} ║`,
              '╚════════════════════════════════════════════════════════════════════╝',
              '',
              `Category: ${papers.category}`,
              `Reading Time: ${papers.reading_time || '?'} minutes`,
              `Difficulty: ${papers.difficulty_level || 'N/A'}`,
              '',
              '────────────────────────────────────────────────────────────────────',
              '',
              papers.excerpt_long || papers.excerpt_short || 'No description available.',
              '',
              'Type "papers" to return to the list',
              ''
            ].join('\n')

            return Response.json({
              output,
              type: 'success'
            })
          }

          case 'search': {
            if (!args) {
              return Response.json({
                output: 'Usage: search <query>',
                type: 'error'
              })
            }

            const results = await env.DB.prepare(`
              SELECT id, title, category, excerpt_short
              FROM papers
              WHERE published = 1
              AND (title LIKE ? OR content LIKE ? OR category LIKE ?)
              LIMIT 5
            `).bind(`%${args}%`, `%${args}%`, `%${args}%`).all()

            if (!results.results.length) {
              return Response.json({
                output: `No papers found matching: "${args}"`,
                type: 'info'
              })
            }

            const output = [
              '',
              `Search results for "${args}":`,
              '',
              ...results.results.map((p: any, i: number) =>
                `[${i + 1}] ${p.title} (${p.category})\n    ${p.excerpt_short || 'No description'}`
              ),
              ''
            ].join('\n')

            return Response.json({
              output,
              type: 'success'
            })
          }

          case 'ls': {
            if (path === '/' || !path) {
              return Response.json({
                output: `/
├── papers/
│   ├── automation/
│   ├── webflow/
│   ├── development/
│   └── [5 papers]
├── about/
├── contact/
└── help/`,
                type: 'success'
              })
            }

            if (path.includes('papers')) {
              const papers = await env.DB.prepare(
                'SELECT COUNT(*) as count FROM papers WHERE published = 1'
              ).first()

              return Response.json({
                output: `papers/
└── [${papers?.count || 0} technical papers]`,
                type: 'success'
              })
            }

            return Response.json({
              output: `Directory not found: ${path}`,
              type: 'error'
            })
          }

          case 'cd': {
            if (!args || args === '~' || args === '/') {
              return Response.json({
                output: '',
                type: 'success',
                newPath: '/'
              })
            }

            if (args === '..') {
              const parentPath = path.split('/').slice(0, -1).join('/') || '/'
              return Response.json({
                output: '',
                type: 'success',
                newPath: parentPath
              })
            }

            const newPath = args.startsWith('/')
              ? args
              : path === '/'
              ? `/${args}`
              : `${path}/${args}`

            return Response.json({
              output: '',
              type: 'success',
              newPath
            })
          }

          default:
            return Response.json({
              output: `Command not found: ${command}`,
              type: 'error'
            })
        }
      } catch (error) {
        console.error('Terminal command error:', error)
        return Response.json({
          output: 'Error processing command',
          type: 'error'
        }, { status: 500 })
      }
    }

    // Return a simple HTML page for testing
    return new Response(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>Create Something Terminal</title>
          <style>
            body {
              background: #111;
              color: #0f0;
              font-family: monospace;
              padding: 20px;
            }
            h1 { color: #0ff; }
          </style>
        </head>
        <body>
          <h1>Create Something Terminal</h1>
          <p>TanStack Start + Cloudflare Workers</p>
          <p>Status: Deployed Successfully ✓</p>
          <br>
          <p>Database: ${env.DB ? 'Connected' : 'Not Connected'}</p>
          <p>KV Sessions: ${env.SESSIONS ? 'Connected' : 'Not Connected'}</p>
          <p>KV Cache: ${env.CACHE ? 'Connected' : 'Not Connected'}</p>
          <p>R2 Storage: ${env.STORAGE ? 'Connected' : 'Not Connected'}</p>
        </body>
      </html>
    `, {
      headers: {
        'Content-Type': 'text/html',
      },
    })
  },
}